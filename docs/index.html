<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Oskar Wickström">
  <title>Hyper</title>
<link href="https://fonts.googleapis.com/css?family=Source+Code+Pro|Source+Sans+Pro:400,400i,700" rel="stylesheet">
<link rel="stylesheet" href="tomorrow.min.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="docs.css">
</head>
<body itemscope itemtype="http://schema.org/TechArticle">
<header>
<h1 class="title" itemprop="name">Hyper</h1>
<p class="version" itemprop="version">Version a0c0c86</p>
<cite class="author" itemprop="author">By Oskar Wickström</cite>
</header>
<figure id="header-image">
</figure>
<h2 id="contents">Contents</h2>
<nav id="TOC">
<ul>
<li><a href="#goals">Goals</a></li>
<li><a href="#design">Design</a><ul>
<li><a href="#conn">Conn</a></li>
<li><a href="#middleware">Middleware</a></li>
</ul></li>
<li><a href="#use-cases">Use Cases</a><ul>
<li><a href="#writing-a-full-response">Writing a Full Response</a></li>
<li><a href="#parsing-the-request-body">Parsing the Request Body</a></li>
<li><a href="#enforcing-error-handling">Enforcing Error Handling</a></li>
<li><a href="#cohesion-of-links-forms-and-routes">Cohesion of Links, Forms, and Routes</a></li>
</ul></li>
</ul>
</nav>
<h2 id="goals">Goals</h2>
<p>Composing middleware in NodeJS is a risky business. They mutate the HTTP request and response objects freely, and are often dependent on each others’ side-effects. There are no guarantees that you have stacked the middleware functions in a sensible order, and it is often the case, in my experience, that misconfigured middleware takes a lot of time and effort to debug.</p>
<p>The goals of this little hack, called <em>Hyper</em>, is to make use of row polymorphism and other tasty type system features in PureScript to enforce correctly stacked middleware in HTTP server applications. All effects of middleware should be reflected in the types to ensure that otherwise common mistakes cannot be made. A few examples could be:</p>
<ul>
<li>Trying to consume a non-parsed request body</li>
<li>Consuming a request body parsed as the wrong type</li>
<li>Overwriting headers</li>
<li>Writing multiple responses</li>
<li>Incorrect ordering of error handling middleware</li>
<li>Incorrect ordering of middleware for sessions, authentication, authorization</li>
<li>Missing authentication and/or authorization checks</li>
<li>Linking, in an HTML anchor, to a resource that is not routed</li>
<li>Posting, in an HTML form, to a resource that is not routed</li>
</ul>
<p>Can we, using the PureScript type system, eradicate this class of errors? Let’s find out!</p>
<h2 id="design">Design</h2>
<p>These are the central components of <em>Hyper</em>.</p>
<h3 id="conn">Conn</h3>
<p>A <em>Conn</em>, short for “connection”, models the entirety of a connection between the HTTP server and the user agent - both request and response. This design is adopted from <em>Plug</em>, an abstract HTTP interface in Elixir, that enables various HTTP libraries to inter-operate.</p>
<pre class="purescript"><code>type Conn req res components = { request :: req
                               , response :: res
                               , components :: components
                               }</code></pre>
<h3 id="middleware">Middleware</h3>
<p>A <em>middleware</em> is a function transforming a <code>Conn</code> to another <code>Conn</code>, in some type <code>m</code> (possibly a monad stack). The <code>Middleware</code> type synonym encapsulates this concept, but it is still a regular function.</p>
<pre class="purescript"><code>type Middleware m c c&#39; = c -&gt; m c&#39;</code></pre>
<p>Being able to parameterize <code>Conn</code> with an <code>Applicative</code>, or <code>Monad</code> stack, you can customize the chain depending on the needs of your middleware and handlers.</p>
<h2 id="use-cases">Use Cases</h2>
<p><em>Here follows a collection of still loosely organized thoughts on how to implement safe middleware in Hyper. Very much work-in-progress.</em></p>
<h3 id="writing-a-full-response">Writing a Full Response</h3>
<p>A function which writes a complete response could take a <code>Conn</code> with an empty response.</p>
<pre class="purescript"><code>respond s :: forall req res c h. String
          -&gt; Middleware
             (Conn req { body :: Stream Write Initial | res } c)
             (Conn
              req
              { headers :: { &quot;content-type&quot; :: String
                           , &quot;content-length&quot; :: String
                           | h
                           }
              , body :: Stream Write Closed
              | res
              }
              c)</code></pre>
<h3 id="parsing-the-request-body">Parsing the Request Body</h3>
<p>The request body is initially a <code>Stream Read Initial</code> in the connection. It might not always be of interest, thus it is not read, and not parsed, by default. Instead, the user explicitly chooses to read and parse the body with a given parser, which returns a new connection of a type reflecting the action.</p>
<pre class="purescript"><code>class BodyParser p t | p -&gt; t where
  parse :: forall req res c h. p
        -&gt; Middleware
           (Conn
            { bodyStream :: Stream Read Initial
            , headers :: { &quot;content-type&quot; :: String
                         , &quot;content-length&quot; :: String
                         | h
                         }
            | req
            }
            res
            c)
           (Conn
            { bodyStream :: Stream Read Closed
            , headers :: { &quot;content-type&quot; :: String
                         , &quot;content-length&quot; :: String
                         | h
                         }
            , body :: t
            | req
            }
           res
           c)</code></pre>
<p>Given this type, the request body can neither be read more than once, nor can the connection’s <code>body</code> be overwritten. An example parser is the <code>BodyParser</code> instance for <code>FormParser</code> and <code>Form</code>.</p>
<pre class="purescript"><code>-- | A form represents a &quot;www-form-urlencoded&quot; form.
newtype Form = Form (Array (Tuple String String))

-- | Placeholder constructor without any options.
data FormParser = FormParser

instance bodyParserFormParser :: BodyParser FormParser Form where
  parse _ = parseBodyFromString splitPairs
    where
      toTuple :: Array String -&gt; Either Error (Tuple String String)
      toTuple kv =
        case kv of
          [key, value] → Right (Tuple (decodeURIComponent key)
                                      (decodeURIComponent value))
          parts        → Left (error (&quot;Invalid form key-value pair: &quot;
                                      &lt;&gt; joinWith &quot; &quot; parts))
      splitPair = split (Pattern &quot;=&quot;)
      splitPairs ∷ String → Either Error Form
      splitPairs = (&lt;$&gt;) Form
                   &lt;&lt;&lt; sequence
                   &lt;&lt;&lt; map toTuple
                   &lt;&lt;&lt; map splitPair
                   &lt;&lt;&lt; split (Pattern &quot;&amp;&quot;)</code></pre>
<p>This instance uses the helper <code>parseBodyFromString</code> to first read the body as a string, then parse that string as a <code>www-form-urlencoded</code> form. Any invalid form will throw an error in the Aff monad, which can be caught and handled.</p>
<h3 id="enforcing-error-handling">Enforcing Error Handling</h3>
<p><em>TODO!</em></p>
<h3 id="cohesion-of-links-forms-and-routes">Cohesion of Links, Forms, and Routes</h3>
<p>It should not be possible to link, using an HTML anchor, to a resource in the web application that does not exist, or that does not handle the GET method. Neither should it be possible to create a form that posts to a non-existing resource, or a resource not handling POST requests.</p>
<h4 id="resources">Resources</h4>
<p>Hyper has a concept of <em>resources</em>. Each resource is a record describing its <em>path</em>, along with a set of HTTP methods and handlers. Each method implemented in Hyper must be specified explicitly in the record with a <code>ResourceMethod</code> value, and those values are parameterized with one of the marker types describing if it is routed - <code>Supported</code> or <code>NotSupported</code>. The helper functions <code>handler</code> and <code>notSupported</code> are used to construct <code>ResourceMethod</code> values.</p>
<pre class="purescript"><code>index =
  { path: []
  , &quot;GET&quot;: handler (html (h1 (text &quot;Welcome!&quot;)))
  , &quot;POST&quot;: notSupported
  }</code></pre>
<h4 id="resource-routers">Resource Routers</h4>
<p>The <code>resource</code> function creates a <code>ResourceRouter</code> that tries to route HTTP requests to handlers in its resource. It should also add the application resources as a type in the components of the Conn, giving subsequent middleware access to that information. <em>The encoding of resource types in the Conn is NOT supported yet.</em></p>
<pre class="purescript"><code>app = fallbackTo notFound (resource index)</code></pre>
<p>The <code>ResourceRouter</code> provides an instance for <code>Alt</code>, making it possible to chain resources and have them try to match the request in order.</p>
<pre class="purescript"><code>app = fallbackTo notFound (resource index &lt;|&gt; resource about &lt;|&gt; resource contact)</code></pre>
<h4 id="html-dsl">HTML DSL</h4>
<p>A separate DSL for writing HTML, providing functions that take resources as arguments, creates links and forms to resources in the application <em>only if they are in scope and support the required HTTP methods</em>. Paths are used from the resource, so you cannot make a typo in the URL. In other words, mistakes in routing and references between resources give you compile-time errors.</p>
<pre class="purescript"><code>about =
  { path: [&quot;about&quot;]
  , &quot;GET&quot;: handler (\conn -&gt; html
                            (linkTo contact (text &quot;Contact Me!&quot;))
                            conn)
  , &quot;POST&quot;: notSupported
  }

contact =
  { path: [&quot;contact&quot;]
  , &quot;GET&quot;: handler (\conn -&gt; html
                             (linkTo about (text &quot;About Me&quot;))
                             conn)
  , &quot;POST&quot;: notSupported
  }</code></pre>
<p>As resources have to be in scope to be referred, you cannot refer to a non-existing resource. You can, however, refer to an existing resource <em>that is not routed</em>. This is described above in <a href="#resource-routers">Resource Routers</a>.</p>
<p>Erroneously using the <code>about</code> resource together with <code>formTo</code> results in a compile error, as there is no handler for the <code>POST</code> method in <code>about</code>.</p>
<pre class="text"><code>Error found:
in module Hyper.HTML.Example

  Could not match type

    Unsupported

  with type

    Supported
</code></pre>
<h4 id="open-issues">Open Issues</h4>
<ul>
<li>Encoding routed resources in the Conn type (see <a href="#resource-routers">Resource Routers</a>)</li>
<li>Path parameters (Hyper currently only supports literal path segments)</li>
<li>How to handle external links</li>
</ul>
<footer>
  <p>
  The
  Hyper
    <a href="https://github.com/owickstrom/hyper">source code</a>
    is licensed under <a href="https://raw.githubusercontent.com/owickstrom/hyper/master/LICENSE">Mozilla Public License 2.0</a>.</p>
  <p>Copyright &copy; 2016 <a href="https://wickstrom.tech">Oskar Wickström</a>.</p>
</footer>
<script src="jquery.js"></script>
<script src="highlight.min.js"></script>
<script src="haskell.min.js"></script>
<script src="highlight.js"></script>
</body>
</html>
